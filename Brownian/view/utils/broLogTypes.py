"""This file describes the Bro logs and the various field types.

TODO: This needs to be auto-generated and sent to ES by Bro, but currently the field descriptions are just comments."""

class Field(object):
    def __init__(self, name, type, description):
        self.name = name
        self.type = type
        self.description = description

broLogs = {
    "app_stats": [
        Field("ts", "time", "Timestamp when the log line was finished and written."),
        Field("ts_delta", "interval", "Time interval that the log line covers"),
        Field("app", "string", "The name of the \"app\", like \"facebook\" or \"netflix\"."),
        Field("uniq_hosts", "count", "The number of unique local hosts using the app."),
        Field("hits", "count", "The total number of hits to the app."),
        Field("bytes", "count", "The total number of bytes received by users of the app."),
    ],
    "capture_loss": [
        Field("ts", "time", "Timestamp for when the measurement occurred."),
        Field("ts_delta", "interval", "The time delay between this measurement and the last."),
        Field("peer", "string", "In the event that there are multiple Bro instances logging to the same host, this distinguishes each peer with its individual name."),
        Field("gaps", "count", "Number of missed ACKs from the previous measurement interval."),
        Field("acks", "count", "Total number of ACKs seen in the previous measurement interval."),
        Field("percent_lost", "string", "Percentage of ACKs seen where the data being ACKed wasn't seen."),
    ],
    "cluster": [
        Field("ts", "time", "The time at which a cluster message was generated."),
        Field("message", "string", "A message indicating information about the cluster's operation."),
    ],
    "communication": [
        Field("ts", "time", "The network time at which a communication event occurred."),
        Field("peer", "string", "The peer name (if any) for which a communication event is concerned."),
        Field("src_name", "string", "Where the communication event message originated from, that is, either from the scripting layer or inside the Bro process."),
        Field("connected_peer_desc", "string", "TODO: currently unused."),
        Field("connected_peer_addr", "addr", "TODO: currently unused."),
        Field("connected_peer_port", "port", "TODO: currently unused."),
        Field("level", "string", "The severity of the communication event message."),
        Field("message", "string", "A message describing the communication event between Bro or Broccoli instances."),
    ],
    "conn": [
        Field("ts", "time", "This is the time of the first packet."),
        Field("uid", "string", "A unique identifier of the connection."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "The transport layer protocol of the connection."),
        Field("service", "string", "An identification of an application protocol being sent over the the connection."),
        Field("duration", "interval", "How long the connection lasted. For 3-way or 4-way connection tear-downs, this will not include the final ACK."),
        Field("orig_bytes", "count", "The number of payload bytes the originator sent. For TCP this is taken from sequence numbers and might be inaccurate (e.g., due to large connections)"),
        Field("resp_bytes", "count", "The number of payload bytes the responder sent. See orig_bytes."),
        Field("conn_state", "string", "<table><thead><th>conn_state</th><th>Meaning</th></thead><tbody><tr><td>S0</td><td>Connection attempt seen, no reply.</tr><tr><td>S1</td><td>Connection established, not terminated.</td></tr><tr><td>SF</td><td>Normal establishment and termination. Note that this is the same symbol as for state S1. You can tell the two apart because for S1 there will not be any byte counts in the summary, while for SF there will be.</td></tr><tr><td>REJ</td><td>Connection attempt rejected.</td></tr><tr><td>S2</td><td>Connection established and close attempt by originator seen (but no reply from responder).</td></tr><tr><td>S3</td><td>Connection established and close attempt by responder seen (but no reply from originator).</td></tr><tr><td>RSTO</td><td>Connection established, originator aborted (sent a RST).</td></tr><tr><td>RSTR</td><td>Established, responder aborted.</td></tr><tr><td>RSTOS0</td><td>Originator sent a SYN followed by a RST, we never saw a SYN-ACK from the responder.</td></tr><tr><td>RSTRH</td><td>Responder sent a SYN ACK followed by a RST, we never saw a SYN from the (purported) originator.</td></tr><tr><td>SH</td><td>Originator sent a SYN followed by a FIN, we never saw a SYN ACK from the responder (hence the connection was \"half\" open).</td></tr><tr><td>SHR</td><td>Responder sent a SYN ACK followed by a FIN, we never saw a SYN from the originator.</td></tr><tr><td>OTH</td><td>No SYN seen, just midstream traffic (a \"partial connection\" that was not later closed).</td></tr></tbody></table"),
        Field("local_orig", "bool", "If the connection is originated locally, this value will be T. If it was originated remotely it will be F. In the case that the Site::local_nets variable is undefined, this field will be left empty at all times."),
        Field("missed_bytes", "count", "Indicates the number of bytes missed in content gaps which is representative of packet loss. A value other than zero will normally cause protocol analysis to fail but some analysis may have been completed prior to the packet loss."),
        Field("history", "string", "Records the state history of connections as a string of letters. For TCP connections the meaning of those letters is:<table><thead><th>Letter</th><th>Meaning</th></thead><tbody><tr><td>s</td><td>a SYN w/o the ACK bit set</td></tr><tr><td>h</td><td>a SYN+ACK (\"handshake\")</td></tr><tr><td>a</td><td>a pure ACK</td></tr><tr><td>d</td><td>packet with payload (\"data\")</td></tr><tr><td>f</td><td>packet with FIN bit set</td></tr><tr><td>r</td><td>packet with RST bit set</td></tr><tr><td>c</td><td>packet with a bad checksum</td></tr><tr><td>i</td><td>inconsistent packet (e.g. SYN+RST bits both set)</td></tr></tbody></table>If the letter is in upper case it means the event comes from the originator and lower case then means the responder. Also, there is compression. We only record one \"d\" in each direction, for instance. I.e., we just record that data went in that direction. This history is not meant to encode how much data that happened to be."),
        Field("orig_pkts", "count", "Number of packets the originator sent. Only set if use_conn_size_analyzer = T"),
        Field("orig_ip_bytes", "count", "Number IP level bytes the originator sent (as seen on the wire, taken from IP total_length header field). Only set if use_conn_size_analyzer = T"),
        Field("resp_pkts", "count", "Number of packets the responder sent. See orig_pkts."),
        Field("resp_ip_bytes", "count", "Number IP level bytes the responder sent. See orig_pkts."),
        Field("tunnel_parents", "set", "If this connection was over a tunnel, indicate the <em>uid</em> values for any encapsulating parent connections used over the lifetime of this inner connection."),
        Field("orig_cc", "string", "The originating endpoint's GeoIP country code."),
        Field("resp_cc", "string", "The responding endpoint's GeoIP country code."),
    ],
    "dhcp": [
        Field("ts", "time", "The earliest time at which a DHCP message over the associated connection is observed."),
        Field("uid", "string", "A unique identifier of the connection over which DHCP is occuring."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("mac", "string", "Client's hardware address."),
        Field("assigned_ip", "addr", "Client's actual assigned IP address."),
        Field("lease_time", "interval", "IP address lease time."),
        Field("trans_id", "count", "A random number chosen by the client of this transaction."),
    ],
    "dnp3": [
        Field("ts", "time", "Timestamp of the connection."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("fc_request", "string", "The name of the function message in the request."),
        Field("fc_reply", "string", "The name of the function message in the reply."),
        Field("iin", "count", "The response's \"internal indication number\"."),
    ],
    "dns": [
        Field("ts", "time", "The earliest time at which a DNS protocol message over the associated connection is observed."),
        Field("uid", "string", "A unique identifier of the connection over which DNS messages are being transferred."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "The transport layer protocol of the connection."),
        Field("trans_id", "count", "A 16 bit identifier assigned by the program that generated the DNS query. Also used in responses to match up replies to outstanding queries."),
        Field("query", "string", "The domain name that is the subject of the DNS query."),
        Field("qclass", "count", "The QCLASS value specifying the class of the query."),
        Field("qclass_name", "string", "A descriptive name for the class of the query."),
        Field("qtype", "count", "A QTYPE value specifying the type of the query."),
        Field("qtype_name", "string", "A descriptive name for the type of the query."),
        Field("rcode", "count", "The response code value in DNS response messages."),
        Field("rcode_name", "string", "A descriptive name for the response code value."),
        Field("QR", "bool", "Whether the message is a query (F) or response (T)."),
        Field("AA", "bool", "The Authoritative Answer bit for response messages specifies that the responding name server is an authority for the domain name in the question section."),
        Field("TC", "bool", "The Truncation bit specifies that the message was truncated."),
        Field("RD", "bool", "The Recursion Desired bit indicates to a name server to recursively purse the query."),
        Field("RA", "bool", "The Recursion Available bit in a response message indicates if the name server supports recursive queries."),
        Field("Z", "count", "A reserved field that is currently supposed to be zero in all queries and responses."),
        Field("answers", "vector", "The set of resource descriptions in answer of the query."),
        Field("TTLs", "vector", "The caching intervals of the associated RRs described by the answers field."),
        Field("rejected", "bool", "Whether the DNS query was rejected by the server."),
    ],
    "dpd": [
        Field("ts", "time", "Timestamp for when protocol analysis failed."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "Transport protocol for the violation."),
        Field("analyzer", "string", "The analyzer that generated the violation."),
        Field("failure_reason", "string", "The textual reason for the analysis failure."),
    ],
    "files": [
        Field("ts", "time", "The time when the file was first seen."),
        Field("fuid", "string", "An identifier associated with a single file."),
        Field("tx_hosts", "set", "If this file was transferred over a network connection this should show the host or hosts that the data sourced from."),
        Field("rx_hosts", "set", "If this file was transferred over a network connection this should show the host or hosts that the data traveled to."),
        Field("conn_uids", "set", "Connection UIDs over which the file was transferred"),
        Field("source", "string", "An identification of the source of the file data. e.g. it may be a network protocol over which it was transferred, or a local file path which was read, or some other input source."),
        Field("depth", "count", "A value to repesent the depth of this file in relation to its source. In SMTP, it is the depth of the MIME attachment on the message. In HTTP, it is the depth of the request within the TCP connection."),
        Field("analyzers", "set", "A set of analysis types done during the file analysis."),
        Field("mime_type", "string", "A mime type provided by libmagic against the bof_buffer, or in the cases where no buffering of the beginning of the file occurs, an initial guess of the mime type based on the first data seen."),
        Field("filename", "string", "A filename for the file if one is available from the source for the file. These will frequently come from \"Content-Disposition\" headers in network protocols."),
        Field("duration", "interval", "The duration the file was analyzed for."),
        Field("local_orig", "bool", "If the source of this file is a network connection, this field indicates if the data originated from the local network or not as determined by the configured Site::local_nets."),
        Field("is_orig", "bool", "If the source of this file is a network conneciton, this field indicates if the file is being sent by the originator of the connection or the responder."),
        Field("seen_bytes", "count", "Number of bytes provided to the file analysis engine for the file."),
        Field("total_bytes", "count", "Total number of bytes that are supposed to comprise the full file."),
        Field("missing_bytes", "count", "The number of bytes in the file stream that were completely missed during the process of analysis e.g. due to dropped packets."),
        Field("overflow_bytes", "count", "The number of not all-in-sequence bytes in the file stream that were delivered to file analyzers due to reassembly buffer overflow."),
        Field("timedout", "bool", "Whether the file analysis timed out at least once for the file."),
        Field("parent_fuid", "string", "Identifier associated with a container file from which this one was extracted as part of the file analysis."),
        Field("md5", "string", "An MD5 digest of the file contents."),
        Field("sha1", "string", "A SHA1 digest of the file contents."),
        Field("sha256", "string", "A SHA256 digest of the file contents."),
        Field("extracted", "string", "Local filename of extracted file."),
    ],
    "ftp": [
        Field("ts", "time", "Timestamp for when the command was sent."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("user", "string", "User name for the current FTP session."),
        Field("password", "string", "Password for the current FTP session if captured."),
        Field("command", "string", "Command given by the client."),
        Field("arg", "string", "Argument for the command if one is given."),
        Field("mime_type", "string", "Libmagic \"sniffed\" file type if the command indicates a file transfer."),
        Field("file_size", "count", "Size of the file if the command indicates a file transfer."),
        Field("reply_code", "count", "Reply code from the server in response to the command."),
        Field("reply_msg", "string", "Reply message from the server in response to the command."),
        Field("data_channel.passive", "bool", "Whether PASV mode is toggled for the control channel."),
        Field("data_channel.orig_h", "addr", "The host that will be initiating the data connection."),
        Field("data_channel.resp_h", "addr", "The host that will be accepting the data connection."),
        Field("data_channel.resp_p", "port", "The port at which the acceptor is listening for the data connection."),
        Field("fuid", "string", "File unique ID."),
    ],
    "http": [
        Field("ts", "time", "Timestamp for when the request happened."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("trans_depth", "count", "Represents the pipelined depth into the connection of this request/response transaction."),
        Field("method", "string", "Verb used in the HTTP request (GET, POST, HEAD, etc.)."),
        Field("host", "string", "Value of the HOST header."),
        Field("uri", "string", "URI used in the request."),
        Field("referrer", "string", "Value of the \"referer\" header. The comment is deliberately misspelled like the standard declares, but the name used here is \"referrer\" spelled correctly."),
        Field("user_agent", "string", "Value of the User-Agent header from the client."),
        Field("request_body_len", "count", "Actual uncompressed content size of the data transferred from the client."),
        Field("response_body_len", "count", "Actual uncompressed content size of the data transferred from the server."),
        Field("status_code", "count", "Status code returned by the server."),
        Field("status_msg", "string", "Status message returned by the server."),
        Field("info_code", "count", "Last seen 1xx informational reply code returned by the server."),
        Field("info_msg", "string", "Last seen 1xx informational reply message returned by the server."),
        Field("filename", "string", "Filename given in the Content-Disposition header sent by the server."),
        Field("tags", "set", "A set of indicators of various attributes discovered and related to a particular request/response pair."),
        Field("username", "string", "Username if basic-auth is performed for the request."),
        Field("password", "string", "Password if basic-auth is performed for the request."),
        Field("proxied", "set", "All of the headers that may indicate if the request was proxied."),
        Field("orig_fuids", "vector", "An ordered vector of file unique IDs."),
        Field("orig_mime_types", "vector", "An ordered vector of mime types."),
        Field("resp_fuids", "vector", "An ordered vector of file unique IDs."),
        Field("resp_mime_types", "vector", "An ordered vector of mime types."),
        Field("client_header_names", "vector", "The vector of HTTP header names sent by the client. No header values are included here, just the header names."),
        Field("server_header_names", "vector", "The vector of HTTP header names sent by the server. No header values are included here, just the header names."),
        Field("cookie_vars", "vector", "Variable names extracted from all cookies."),
        Field("uri_vars", "vector", "Variable names from the URI."),
    ],
    "intel": [
        Field("ts", "time", "Timestamp for when the data was discovered."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("fuid", "string", "If a file was associated with this intelligence hit, this is the uid for that file."),
        Field("file_mime_type", "string", "A mime type if the intelligence hit is related to a file."),
        Field("file_desc", "string", "Frequently files can be \"described\" to give a bit more context."),
        Field("seen.indicator", "string", "The intelligence indicator."),
        Field("seen.indicator_type", "string", "The type of data that the indicator represents."),
        Field("seen.where", "string", "Where the data was discovered."),
        Field("sources", "set", "Sources which supplied data that resulted in this match."),
    ],
    "irc": [
        Field("ts", "time", "Timestamp for when the command was seen."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("nick", "string", "Nick name given for the connection."),
        Field("user", "string", "User name given for the connection."),
        Field("command", "string", "Command given by the client."),
        Field("value", "string", "Value for the command given by the client."),
        Field("addl", "string", "Any additional data for the command."),
        Field("dcc_file_name", "string", "DCC filename requested."),
        Field("dcc_file_size", "count", "Size of the DCC transfer as indicated by the sender."),
        Field("dcc_mime_type", "string", "Sniffed mime type of the file."),
        Field("fuid", "string", "File unique ID."),
    ],
    "known_certs": [
        Field("ts", "time", "The timestamp when the certificate was detected."),
        Field("host", "addr", "The address that offered the certificate."),
        Field("port_num", "port", "If the certificate was handed out by a server, this is the port that the server waslistening on."),
        Field("subject", "string", "Certificate subject."),
        Field("issuer_subject", "string", "Certificate issuer subject."),
        Field("serial", "string", "Serial number for the certificate."),
    ],
    "known_devices": [
        Field("ts", "time", "The timestamp at which the host was detected."),
        Field("mac", "string", "The MAC address that was detected."),
        Field("dhcp_host_name", "string", "The value of the DHCP host name option, if seen."),
    ],
    "known_hosts": [
        Field("ts", "time", "The timestamp at which the host was detected."),
        Field("host", "addr", "The address that was detected originating or responding to a TCP connection."),
    ],
    "known_services": [
        Field("ts", "time", "The time at which the service was detected."),
        Field("host", "addr", "The host address on which the service is running."),
        Field("port_num", "port", "The port number on which the service is running."),
        Field("port_proto", "transport_proto", "The transport-layer protocol which the service uses."),
        Field("service", "set", "A set of protocols that match the service's connection payloads."),
    ],
    "loaded_scripts": [
        Field("name", "string", "Name of the script loaded potentially with spaces included before the file name to indicate load depth. The convention is two spaces per level of depth."),
    ],
    "modbus": [
        Field("ts", "time", "Timestamp of the request."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("func", "string", "The name of the function message that was sent."),
        Field("exception", "string", "The exception if the response was a failure."),
    ],
    "notice": [
        Field("ts", "time", "An absolute time indicating when the notice occurred, defaults to the current network time."),
        Field("uid", "string", "A connection UID which uniquely identifies the endpoints concerned with the notice."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("fuid", "string", "A file unique ID if this notice is related to a file."),
        Field("file_mime_type", "string", "A mime type if the notice is related to a file."),
        Field("file_desc", "string", "Frequently files can be \"described\" to give a bit more context."),
        Field("proto", "transport_proto", "The transport protocol. Filled automatically when either conn, iconn or p is specified."),
        Field("note", "Notice", "The Notice::Type of the notice."),
        Field("msg", "string", "The human readable message for the notice."),
        Field("sub", "string", "The human readable sub-message."),
        Field("src", "addr", "Source address, if we don't have a conn_id."),
        Field("dst", "addr", "Destination address."),
        Field("p", "port", "Associated port, if we don't have a conn_id."),
        Field("n", "count", "Associated count, or perhaps a status code."),
        Field("peer_descr", "string", "Textual description for the peer that raised this notice."),
        Field("actions", "set", "The actions which have been applied to this notice."),
        Field("suppress_for", "interval", "This field indicates the length of time that this unique notice should be suppressed. This field is automatically filled out and should not be written to by any other script."),
        Field("dropped", "bool", "Indicates if the $src IP address was dropped and denied network access."),
        Field("remote_location.country_code", "string", "The country code of the remote endpoint."),
        Field("remote_location.region", "string", "The region of the remote endpoint."),
        Field("remote_location.city", "string", "The city of the remote endpoint."),
        Field("remote_location.latitude", "string", "The latitude of the remote endpoint."),
        Field("remote_location.longitude", "string", "The longitude of the remote endpoint."),
    ],
    "notice_policy": [
        Field("position", "count", "This is the exact positional order in which the Notice::PolicyItem records are checked. This is set internally by the notice framework."),
        Field("priority", "count", "Define the priority for this check. Items are checked in ordered from highest value (10) to lowest value (0)."),
        Field("action", "Notice", "An action given to the notice if the predicate return true."),
        Field("pred", "function", "The pred (predicate) field is a function that returns a boolean T or F value. If the predicate function return true, the action in this record is applied to the notice that is given as an argument to the predicate function. If no predicate is supplied, it's assumed that the PolicyItem always applies."),
        Field("halt", "bool", "Indicates this item should terminate policy processing if the predicate returns T."),
        Field("suppress_for", "interval", "This defines the length of time that this particular notice should be suppressed."),
    ],
    "packet_filter": [
        Field("ts", "time", "The time at which the packet filter installation attempt was made."),
        Field("node", "string", "This is a string representation of the node that applied this packet filter. It's mostly useful in the context of dynamically changing filters on clusters."),
        Field("filter", "string", "The packet filter that is being set."),
        Field("init", "bool", "Indicate if this is the filter set during initialization."),
        Field("success", "bool", "Indicate if the filter was applied successfully."),
    ],
    "reporter": [
        Field("ts", "time", "The network time at which the reporter event was generated."),
        Field("level", "Reporter", "The severity of the reporter message."),
        Field("message", "string", "An info/warning/error message that could have either been generated from the internal Bro core or at the scripting-layer."),
        Field("location", "string", "This is the location in a Bro script where the message originated. Not all reporter messages will have locations in them though."),
    ],
    "signatures": [
        Field("ts", "time", "The network time at which a signature matching type of event to be logged has occurred."),
        Field("src_addr", "addr", "The host which triggered the signature match event."),
        Field("src_port", "port", "The host port on which the signature-matching activity occurred."),
        Field("dst_addr", "addr", "The destination host which was sent the payload that triggered the signature match."),
        Field("dst_port", "port", "The destination host port which was sent the payload that triggered the signature match."),
        Field("note", "Notice", "Notice associated with signature event"),
        Field("sig_id", "string", "The name of the signature that matched."),
        Field("event_msg", "string", "A more descriptive message of the signature-matching event."),
        Field("sub_msg", "string", "Extracted payload data or extra message."),
        Field("sig_count", "count", "Number of sigs, usually from summary count."),
        Field("host_count", "count", "Number of hosts, from a summary count."),
    ],
    "smtp": [
        Field("ts", "time", "Timestamp when the message was first seen."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("trans_depth", "count", "A count to represent the depth of this message transaction in a single connection where multiple messages were transferred."),
        Field("helo", "string", "Contents of the Helo header."),
        Field("mailfrom", "string", "Contents of the From header."),
        Field("rcptto", "set", "Contents of the Rcpt header."),
        Field("date", "string", "Contents of the Date header."),
        Field("from", "string", "Contents of the From header."),
        Field("to", "set", "Contents of the To header."),
        Field("reply_to", "string", "Contents of the ReplyTo header."),
        Field("msg_id", "string", "Contents of the MsgID header."),
        Field("in_reply_to", "string", "Contents of the In-Reply-To header."),
        Field("subject", "string", "Contents of the Subject header."),
        Field("x_originating_ip", "addr", "Contents of the X-Originating-IP header."),
        Field("first_received", "string", "Contents of the first Received header."),
        Field("second_received", "string", "Contents of the second Received header."),
        Field("last_reply", "string", "The last message the server sent to the client."),
        Field("path", "vector", "The message transmission path, as extracted from the headers."),
        Field("user_agent", "string", "Value of the User-Agent header from the client."),
        Field("fuids", "vector", "An ordered vector of file unique IDs seen attached to the message."),
        Field("is_webmail", "bool", "Boolean indicator of if the message was sent through a webmail interface."),
    ],
    "socks": [
        Field("ts", "time", "Timestamp when the proxy connection was first detected."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("version", "count", "Protocol version of SOCKS."),
        Field("user", "string", "Username for the proxy if extracted from the network."),
        Field("status", "string", "Server status for the attempt at using the proxy."),
        Field("request.host", "addr", "Client requested address."),
        Field("request.name", "string", "Client requested name."),
        Field("request_p", "port", "Client requested port."),
        Field("bound.host", "addr", "Server bound address."),
        Field("bound.name", "string", "Server bound name."),
        Field("bound_p", "port", "Server bound port."),
    ],
    "software": [
        Field("ts", "time", "Timestamp when the software was first detected."),
        Field("host", "addr", "The IP address detected running the software."),
        Field("host_p", "port", "The port detected running the software."),
        Field("software_type", "Software", "The type of software detected (e.g. HTTP::SERVER)."),
        Field("name", "string", "Name of the software (e.g. Apache)."),
        Field("version.major", "count", "Major version number."),
        Field("version.minor", "count", "Minor version number."),
        Field("version.minor2", "count", "Minor subversion number."),
        Field("version.minor3", "count", "Minor updates number."),
        Field("version.addl", "string", "Additional version string (e.g. \"beta42\")."),
        Field("unparsed_version", "string", "The full unparsed version string found because the version parsing doesn't always work reliably in all cases and this acts as a fallback in the logs."),
    ],
    "ssh": [
        Field("ts", "time", "Timestamp when the SSH connection was first detected."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("status", "string", "Indicates if the login was heuristically guessed to be \"success\" or \"failure\"."),
        Field("direction", "Direction", "Direction of the connection. If the client was a local host logging into an external host, this would be OUTBOUND. INBOUND would be set for the opposite situation."),
        Field("client", "string", "Software string given by the client."),
        Field("server", "string", "Software string given by the server."),
        Field("resp_size", "count", "Amount of data returned from the server. This is currently the only measure of the success heuristic and it is logged to assist analysts looking at the logs to make their own determination about the success on a case-by-case basis."),
        Field("remote_location.country_code", "string", "The country code of the remote endpoint."),
        Field("remote_location.region", "string", "The region of the remote endpoint."),
        Field("remote_location.city", "string", "The city of the remote endpoint."),
        Field("remote_location.latitude", "string", "The latitude of the remote endpoint."),
        Field("remote_location.longitude", "string", "The longitude of the remote endpoint."),
    ],
    "ssl": [
        Field("ts", "time", "Timestamp when the SSL connection was first detected."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("version", "string", "SSL/TLS version the server offered."),
        Field("cipher", "string", "SSL/TLS cipher suite the server chose."),
        Field("server_name", "string", "Value of the Server Name Indicator SSL/TLS extension. It indicates the server name that the client was requesting."),
        Field("session_id", "string", "Session ID offered by the client for session resumption."),
        Field("subject", "string", "Subject of the X.509 certificate offered by the server."),
        Field("issuer_subject", "string", "Subject of the signer of the X.509 certificate offered by the server."),
        Field("not_valid_before", "time", "NotValidBefore field value from the server certificate."),
        Field("not_valid_after", "time", "NotValidAfter field value from the serve certificate."),
        Field("last_alert", "string", "Last alert that was seen during the connection."),
        Field("client_subject", "string", "Subject of the X.509 certificate offered by the client."),
        Field("client_issuer_subject", "string", "Subject of the signer of the X.509 certificate offered by the client."),
        Field("cert_hash", "string", "MD5 sum of the raw server certificate."),
        Field("validation_status", "vector", "Result of certificate validation for this connection."),
    ],
    "stats": [
        Field("ts", "time", "Timestamp for the measurement."),
        Field("peer", "string", "Peer that generated this log. Mostly for clusters."),
        Field("mem", "count", "Amount of memory currently in use in MB."),
        Field("pkts_proc", "count", "Number of packets processed since the last stats interval."),
        Field("events_proc", "count", "Number of events that been processed since the last stats interval."),
        Field("events_queued", "count", "Number of events that have been queued since the last stats interval."),
        Field("lag", "interval", "Lag between the wall clock and packet timestamps if reading live traffic."),
        Field("pkts_recv", "count", "Number of packets received since the last stats interval if reading live traffic."),
        Field("pkts_dropped", "count", "Number of packets dropped since the last stats interval if reading live traffic."),
        Field("pkts_link", "count", "Number of packets seen on the link since the last stats interval if reading live traffic."),
    ],
    "syslog": [
        Field("ts", "time", "Timestamp when the syslog message was seen."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "Protocol over which the message was seen."),
        Field("facility", "string", "Syslog facility for the message."),
        Field("severity", "string", "Syslog severity for the message."),
        Field("message", "string", "The plain text message."),
    ],
    "tunnel": [
        Field("ts", "time", "Timestamp when some tunnel activity occurred."),
        Field("uid", "string", "Unique ID for the tunnel - may correspond to connection uid or be non-existant"),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port - 0 in the case of an IP tunnel."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port - 0 in the case of an IP tunnel."),
        Field("tunnel_type", "Tunnel::Type", "The type of tunnel."),
        Field("action", "Action", "The type of activity that occured."),
    ],
    "weird": [
        Field("ts", "time", "Timestamp when the weird occurred."),
        Field("uid", "string", "If a connection is associated with this weird, this will be the connection's unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address - optional."),
        Field("id.orig_p", "port", "The originating endpoint's port - optional."),
        Field("id.resp_h", "addr", "The responding endpoint's address - optional."),
        Field("id.resp_p", "port", "The responding endpoint's port - optional."),
        Field("name", "string", "The name of the weird that occurred."),
        Field("addl", "string", "Additional information accompanying the weird if any."),
        Field("notice", "bool", "Indicate if this weird was also turned into a notice."),
        Field("peer", "string", "The peer that originated this weird. This is helpful in cluster deployments if a particular cluster node is having trouble to help identify which node is having trouble."),
    ],
}
